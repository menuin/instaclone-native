# 🌴 DEVLOG 8/1

### #15.8 Photo Part 3

- caption, actions, action 파트 

- Likes.js, Comments.js 추가 (sharedStackNavigator)



### #15.9 Pull to Refresh

- 위로 당기면 새로고침하기

1. FlatList 에 refreshing prop 추가 (refreshing={true})
2. onRefresh prop 추가 (화면을 당겼을때 새로고침되는 function)



- onRefresh할때 refetch 해야함

```js
const { data, loading, refetch } = useQuery(FEED_QUERY);
// refetch : query를 불러오는 function

const [refreshing, setRefreshing] = useState(false);
  return (
    <ScreenLayout loading={loading}>
      <FlatList
        refreshing={refreshing}
        onRefresh={refetch}
		...
```

-  이렇게 해도됨

```js
const refresh = async() => {
    setRefreshing(true);
    await refetch();
    setRefreshing(false);
}
```





### #15.10 Infinite Scrolling part 1

- infinite scrolling
- 백엔드 코드 수정
  - seeFeed query로 offset 보냄

```js
// seeFeed.resolvers
seeFeed: protectedResolver((_, { offset }, { loggedInUser }) => client.photo.findMany({
            take: 2,
            skip: offset,
```

```js
// Feed.js
export default function Feed({ navigation }) {
  const [offset, setOffset] = useState(0);
  const { data, loading, refetch } = useQuery(FEED_QUERY,{
    variables:{
      offset, // 쿼리로 보냄
    }
  });
```



1. onEndReached : 사용자가 스크롤 마지막에 도달했다고 react native가 인지했을 때 호출되는 함수
   - 근데 사용자가 스크롤 끝에 도달하기 전에 다음 사진을 preload 해야함!

2. onEndReachedThreshold : 스크롤바의 끝지점이 어디인지 설정할 수 있음

```js
<FlatList
    onEndReachedThreshold={0}
    onEndReached={() => setOffset(2)}
```

- 더 자연스럽게 로딩 (지금은 뚝뚝끊김)
  - fetchmore : query 다시 불러옴

```js
onEndReached={()=>fetchMore({
          varaibles : {
              // 현재 feed에 있는 리스트 길이만큼 skip
            offset: data?.seeFeed?.length
          }
        })}
```

- fetchmore는 되고 있는데 cache에 있는 데이터가 변경되지 않고 있음



### #15.11 Infinite Scrolling part 2

- fetchMore : 기존 데이터는 놔두고 새로운 데이터를 추가
- fetch는 제대로 했는데 apollo가 추가된 데이터를 cache에 반영하지 않고 있음
  - component의 state(offset 값)에 변화 x - 컴포넌트의 state를 바꿔야 re render함!!

- apollo가 데이터 처리 방식을 모름 : fetch한 query가 그 이전의 query와 같다는 사실을 모름 (두 데이터를 결합해야함) 

  지금 query들을 argument(offset)에 따라 독립된 폴더 같은 곳에 따로 따로 저장 => 이렇게 하지 말라고 알려줘야 함!  



- **typePolicies** : type을 설정 
  - seeFeed query에 한해서만 argument 구별 금지

```js
// apollo.js

const client = new ApolloClient({
    link: authLink.concat(httpLink),
    cache: new InMemoryCache({
        typePolicies : {
            Query : {
                fields : {
                    seeFeed : {
                        keyArgs : false
                    }
                }
            }
        }
    }),
})
```

- 새로운 데이터와 기존 데이터 합치기
  - 처음 시작할때 existing은 empty array

```js
seeFeed: {
    keyArgs: false,
	merge(existing=[], incoming=[]){
        return [...existing, ...incoming];
	},
}
```



- offsetLimitPagination : 위 코드 전부 대체

```js
const client = new ApolloClient({
    link: authLink.concat(httpLink),
    cache: new InMemoryCache({
        typePolicies: {
            Query: {
                fields: {
                    seeFeed: offsetLimitPagination()
                }
            }
        }
    }),
})
```



