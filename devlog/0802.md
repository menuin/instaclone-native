# 🍉 DEVLOG 8/2



### #16.2  Header Domination

- header를 사용자에 따라 dynamic 하게 바꾸기 (component를 헤더에 넣기)

- route object에 컴포넌트로 보내진 parameter들이 담김

  ```js
  export default function Profile({navigation, route}) {
  ```

- navigation object의 setOptions 사용

```js
useEffect(() => {
    if (route?.params?.username) {
        navigation.setOptions({
        title: route.params.username,
        })
}
}, [])
```



- Me screen 헤더에 내 username 뜨게 하기

  - useMe hook추가 (프론트에서 가져옴)
  - 위랑 똑같이 함

  ```js
  // Me.js
      const { data } = useMe();
      useEffect(() => {
          navigation.setOptions({
              title: data?.me?.username,
          })
      }, [])
  ```



### #16.3 Search part 1

- 헤더에 컴포넌트를 넣을 수 있음

```js
// Search.js
const SearchBox = () => {
        return (
            <TextInput
                style={{ backgroundColor: "white" }}
                placeholderTextColor="black"
                placeholder="Search photos"
                autoCapitalize="none"
                returnKeyType="search" />
        )
    }
    useEffect(() => {
        navigation.setOptions({
            headerTitle: SearchBox,
        })
    }, [])
```

- dismissKeyboard (login에서 했었음 #14.8) 컴포넌트로 빼기

 

- state 만들기

```js
const { setValue, register, watch } = useForm();

    const SearchBox = () => {
        return (
            <TextInput
	
                onChangeText={(text) => setValue("keyword", text)} />
        )
    }
    
useEffect(() => {
    navigation.setOptions({
        headerTitle: SearchBox,
    })
    register("keyword")
}, []);
```



### #16.4 Search part 2

- tab bar 에 user profile icon을 로그인한 사용자의 프로필 사진으로 바꾸기
  - useMe : user id, username, avatar를 줌, 한번만 실행되고 cache에 저장, 매번 api를 보내지 x 

```js
const {data} = useMe();

tabBarIcon: ({ focused, color, size }) => (
                    data?.me?.avatar ? <Image source={{uri:data.me.avatar}}/> : <TabIcon iconName={"person"} color={color} focused={focused} />)
            }} >
```

- - 네트워크 이미지는 반드시 height, width가 필요

```js
style={{ height: 20, width: 20, borderRadius: 10, ...(focused && { borderColor: "white", borderWidth: 2 }) }}
```



- searchPhotos
  - 쿼리 작성
  - useQuery는 component가 mount 될 때 자동으로 실행되기때문에 사용 x, 사용자가 검색할때만 쿼리 실행 (lazy query)

```js
const [startQueryFn,{loading, data}] = useLazyQuery(SEARCH_PHOTOS)
// startQueryFn 함수를 부를 때 쿼리 실행
```



### #16.5 Search part 3

- TextInput `onSubmitEditing={startQueryFn}`

- watch : 모든 render에서 refresh됨

```js
const [startQueryFn, { loading, data }] = useLazyQuery(SEARCH_PHOTOS, {
    variables: {
        keyword: watch("keyword"),
    }
})
```

- 검색창을 submit 했을 때만 쿼리 실행
- **called** : 함수가 호출되었는지 여부 
  -  submit하기 전에는 Search by keyword 출력

```js
const [startQueryFn, { loading, data, called }] = useLazyQuery(SEARCH_PHOTOS, {
    variables: {
        keyword: watch("keyword"),
    },
});
...

{!called ? (
    <SearchingContainer>
    <SearchingText>Search by keyword</SearchingText>
    </SearchingContainer>
) : null}
```

- 문제 : 한 글자를 입력할 때마다 re-render하고 있음(watch 때문)
- 해결 : onValid function 사용 (data 넘어감)

```js
const onValid = ({ keyword }) => {
    startQueryFn({
        variables: {
            keyword
        }
    });
}

...
<TextInput
	...
	onSubmitEditing={handleSubmit(onValid)}
/>
                     
...
    useEffect(() => {
        ...
        register("keyword", {
            required: true,
            minLength: 3,
        })
    }, []);
```

- search 결과가 없을 경우도 분기

```js
{data?.searchPhotos !== undefined && 
    data?.searchPhotos?.length === 0 ? (
    <MessageContainer>
    <MessageText>Could not find anything.</MessageText>
    </MessageContainer>
) : null}
```

