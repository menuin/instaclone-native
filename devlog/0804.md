# 👻 DEVLOG 8/5

### #17.10 Take Photo part 5

- 사진찍기 => cache에만 저장되고(일시적저장) 파일시스템에 저장되고 있지는 x

- MediaLibrary 이용

1. createAssetAsync : uri 써줘야함, asset 객체 반환

```js
const assets = await MediaLibrary.createAssetAsync(uri);
```

2. saveToLibraryAsync : 아무 객체도 반환하지 x

- 사진 저장할 필요없이 바로 업로드할 수도 있음 	

- 방금 찍은 사진을 화면에 띄우기 (고 업로드하기)

  state사용해서 takenPhoto가 존재하면 사진을 띄우고, 아니면 카메라 컴포넌트 띄우기

```js
const [takenPhoto, setTakenPhoto] = useState("");

const takePhoto = async () => {
    ...
	setTakenPhoto(uri);
}

{takenPhoto === "" ? <Camera 컴포넌트> : <Image 컴포넌트>}
```

- Actions(Slider, takePhoto Button) 도 마찬가지로 하기

```js
{takenPhoto === "" ? (Slider, takePhotoBtn) : (Dismiss, Upload, Save button)}
```



1. Dismiss

```js
const onDismiss = () => setTakenPhoto("");
```



### #17.11 Take Photo part 6

- Uploading Photo
- 버튼 두개 (dismiss, upload) 로 하고 upload를 누르면 저장할건지 물어보는 걸로 변경

```js
    const onUpload = () => {
        Alert.alert("Alert", "Do you want to save before uploading?", 
            [  // array
            {
                text: "Yes",
                onPress: () => goToUpload(true),
            }, {
                text: "No, thanks",
                style: "destructive",   // 빨간색으로 표시됨
                onPress: () => goToUpload(false),
            }]);
    }
    
    
    const goToUpload = async (save) => {
        if (save) {
            // asset 객체가 필요없기 때문에 saveToLibraryAsync 사용
            await MediaLibrary.saveToLibraryAsync(takenPhoto);  // takenPhoto에 방금 찍은 사진의 uri 저장되어있음
        }

    }
```



### #17.12 Upload Screen part 1

- minor bug : select photo 스크린에서도 카메라가 항상 켜져있음 / take photo 화면에서 statusBar 를 숨겼는데 select photo 화면에서도 숨겨짐

  - **focus** 사용

  ```js
  // TakePhoto.js
  const isFocused = useIsFocused();
  
  {isFocused ? <StatusBar hidden={true} /> : null}
  // focused 되지 않았을 경우엔(select photo screen을 보고 있는 경우) status bar 설정이 null이므로 select photo 스크린에 영향을 주지 않음
  ```

  

- upload screen : upload form 을 보여줌
- 중요 : select photo 화면이랑 take photo 화면에서 동시에 같은 스크린을 보여줘야함

1. LoggedInNav 에 새 스택 스크린 추가 (UploadForm)
2. selectPhoto 에서 navigate (next button)
   - 선택한 파일의 uri을 가지고 가야함
   - uploadForm 의 route.params로 확인

```js
<TouchableOpacity onPress={() => navigation.navigate("UploadForm", {
                file : chosenPhoto,
            })}>
```

3. takePhoto에서 navigate
   - 방금 찍은 사진의 uri 가지고 감

```js
    const goToUpload = async (save) => {
        if (save) {
            await MediaLibrary.saveToLibraryAsync(takenPhoto);
        }
        navigation.navigate("UploadForm",{
            file : takenPhoto,
        });
    }
```

- uploadForm 스크린에만 헤더 넣기

```js
 <Stack.Navigator screenOptions={{ presentation: "modal" }}>
            <Stack.Screen name="Tabs" options={{ headerShown: false }} component={TabsNav} />
            <Stack.Screen name="Upload" options={{ headerShown: false }} component={UploadNav} />
                // 얘네 둘만 옵션 줌
            <Stack.Screen name="UploadForm" component={UploadForm} />
        </Stack.Navigator>
```



### #17.13 Upload Screen part 2

- 에러 : select photo에서 uploadForm 스크린으로 넘어갔을때 file이 empty string인 경우

  => navigation.setOptions가 컴포넌트가 mount되었을때 한번만 실행되기 때문 (이때는 선택된 사진이 없으니까!)

  ```js
  useEffect(() => {
          navigation.setOptions({
              headerRight: HeaderRight,
          })
      }, [chosenPhoto]) // 이렇게해서 사진을 선택할 때마다 re render하게 함
  ```

- selectPhoto에서 HeaderRight 가져다 쓰기 => 컴포넌트로 만드는 것 권장

- 기타 : 코드 참고



### #17.14 Upload Screen part 3

- next 버튼 => uploadPhoto mutation 실행 (뒤로 가기버튼 사라지고 next=> loading 으로 바꾸기)

1. mutation 작성 (FEED_PHOTO fragment 이용)

2. 사용

   - mutation loading 중일때 헤더 변경

   ```js
   const [uploadPhotoMutation, { loading }] = useMutation(UPLOAD_PHOTO_MUTATION);
   
   useEffect(() => {
           navigation.setOptions({
               headerRight: loading ? HeaderRightLoading : HeaderRight,
               ...(loading && { headerLeft: () => null }),
   
           })
       }, [loading])
   ```

   - onValid 에서 mutation 실행 
     - npm i apollo-upload-client

   ```js
   import { ReactNativeFile } from "apollo-upload-client";
   
   const onValid = ({ caption }) => {
           const file = new ReactNativeFile({
               uri: route.params.file,
               name : `1.jpg`,
               type : "image/jpeg"
           })
           uploadPhotoMutation({
               variables: {
                   caption,
                   file,
               }
           })
   ```

   💦 에러 : Response not successful : Received status code 400 (백엔드 resolver에 가지도 못함)

   - **Link** 에 관한 이해

     - authLink보다 httpLink가 먼저 오는 이유:

     httpLink는 서버에 마지막으로 요청하는(종료되는) link이기때문에 httpLink를 거치고 나서는 다른 어떤 일도 하면 안되기때문

     ```js
     link: authLink.concat(httpLink),
     ```

   - onErrorLink를 만들어서 중간에 에러를 확인해보자 

```js
import {onError} from "@apollo/client/link/error";

const onErrorLink = onError((error) => {
    console.log(error);
})
const client = new ApolloClient({
    link: authLink.concat(onErrorLink).concat(httpLink),
    cache,
})
```

- ReactNativeFile을 사용하면 httpLink 가 이 파일을 어떻게 다뤄야하는 지 몰라서 발생하는 오류 => 다음시간에 해결





